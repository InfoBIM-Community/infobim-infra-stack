#!/bin/bash

# Define colors
BOLD='\033[1m'
RESET='\033[0m'
CYAN='\033[36m'
GRAY='\033[90m'
WHITE='\033[37m'
YELLOW='\033[33m'
PURPLE='\033[35m'
TEAL='\033[96m'
GREEN='\033[32m'
BLUE='\033[34m'
RED='\033[31m'

# Get terminal width
TERM_WIDTH=$(tput cols)
INNER_WIDTH=$((TERM_WIDTH - 2))

# Generate horizontal line
HLINE=$(printf '─%.0s' $(seq 1 $INNER_WIDTH))
FULL_HLINE=$(printf '─%.0s' $(seq 1 $TERM_WIDTH))

clear

# --- Functions ---
print_box() {
    # --- Title Line ---
    # Text visible length: " >_ InfoBIM (v0.1.0)" = 20 chars
    TITLE_VISIBLE_LEN=20
    TITLE_PAD_LEN=$((INNER_WIDTH - TITLE_VISIBLE_LEN))
    # Ensure non-negative padding
    if [ $TITLE_PAD_LEN -lt 0 ]; then TITLE_PAD_LEN=0; fi
    TITLE_PAD=$(printf '%*s' "$TITLE_PAD_LEN" "")

    # --- Directory Line ---
    # Label visible length: " directory: " = 12 chars
    DIR_LABEL_LEN=12
    DIR=$(pwd | sed "s|$HOME|~|")

    # Calculate available space for directory path
    # INNER_WIDTH - DIR_LABEL_LEN
    MAX_DIR_LEN=$((INNER_WIDTH - DIR_LABEL_LEN))

    # Truncate if necessary
    if [ ${#DIR} -gt $MAX_DIR_LEN ]; then
        DIR="${DIR:0:$((MAX_DIR_LEN-3))}..."
    fi

    DIR_FULL_LEN=$((DIR_LABEL_LEN + ${#DIR}))
    DIR_PAD_LEN=$((INNER_WIDTH - DIR_FULL_LEN))
    if [ $DIR_PAD_LEN -lt 0 ]; then DIR_PAD_LEN=0; fi
    DIR_PAD=$(printf '%*s' "$DIR_PAD_LEN" "")

    # --- Empty Line ---
    EMPTY_PAD=$(printf '%*s' "$INNER_WIDTH" "")

    # Print the box
    echo "╭${HLINE}╮"
    echo -e "│ >_ ${BLUE}${BOLD}InfoBIM${RESET} (v0.1.0)${TITLE_PAD}│"
    echo "│${EMPTY_PAD}│"
    echo -e "│ ${GRAY}directory:${RESET} ${DIR}${DIR_PAD}│"

    # --- Branch Line (Optional) ---
    if git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
        BRANCH=$(git branch --show-current 2>/dev/null || git rev-parse --abbrev-ref HEAD)
        
        # Align with " directory: " (12 chars)
        # " branch:    " (12 chars)
        BRANCH_LABEL_LEN=12
        
        # Calculate available space
        MAX_BRANCH_LEN=$((INNER_WIDTH - BRANCH_LABEL_LEN))
        
        if [ ${#BRANCH} -gt $MAX_BRANCH_LEN ]; then
            BRANCH="${BRANCH:0:$((MAX_BRANCH_LEN-3))}..."
        fi
        
        BRANCH_FULL_LEN=$((BRANCH_LABEL_LEN + ${#BRANCH}))
        BRANCH_PAD_LEN=$((INNER_WIDTH - BRANCH_FULL_LEN))
        if [ $BRANCH_PAD_LEN -lt 0 ]; then BRANCH_PAD_LEN=0; fi
        BRANCH_PAD=$(printf '%*s' "$BRANCH_PAD_LEN" "")
        
        echo -e "│ ${GRAY}branch:${RESET}    ${BRANCH}${BRANCH_PAD}│"
    fi

    echo "╰${HLINE}╯"
}

print_message_box() {
    local COLOR="$1"
    local TITLE_TYPE="$2"    # e.g., "Error", "Success", "Warning"
    local TITLE_TEXT="$3"
    local MSG_TEXT="$4"
    
    # Calculate lengths
    # Title line: " >_ TYPE TITLE"
    # " >_ " is 4 chars.
    
    local TYPE_LEN=${#TITLE_TYPE}
    local TEXT_LEN=${#TITLE_TEXT}
    # Visible length = 4 + TYPE_LEN + 1 (space) + TEXT_LEN
    # If TITLE_TEXT is empty, handle gracefully
    
    local TITLE_VISIBLE_LEN=$((4 + TYPE_LEN))
    if [ -n "$TITLE_TEXT" ]; then
        TITLE_VISIBLE_LEN=$((TITLE_VISIBLE_LEN + 1 + TEXT_LEN))
    fi

    local TITLE_PAD_LEN=$((INNER_WIDTH - TITLE_VISIBLE_LEN))
    if [ $TITLE_PAD_LEN -lt 0 ]; then TITLE_PAD_LEN=0; fi
    local TITLE_PAD=$(printf '%*s' "$TITLE_PAD_LEN" "")
    
    local MSG_LEN=${#MSG_TEXT}
    local MSG_PAD_LEN=$((INNER_WIDTH - MSG_LEN))
    if [ $MSG_PAD_LEN -lt 0 ]; then MSG_PAD_LEN=0; fi
    local MSG_PAD=$(printf '%*s' "$MSG_PAD_LEN" "")
    
    local EMPTY_PAD=$(printf '%*s' "$INNER_WIDTH" "")
    
    echo -e "${COLOR}╭${HLINE}╮${RESET}"
    if [ -n "$TITLE_TEXT" ]; then
        echo -e "${COLOR}│${RESET} >_ ${BOLD}${COLOR}${TITLE_TYPE}${RESET} ${TITLE_TEXT}${TITLE_PAD}${COLOR}│${RESET}"
    else
        echo -e "${COLOR}│${RESET} >_ ${BOLD}${COLOR}${TITLE_TYPE}${RESET}${TITLE_PAD}${COLOR}│${RESET}"
    fi
    echo -e "${COLOR}│${RESET}${EMPTY_PAD}${COLOR}│${RESET}"
    echo -e "${COLOR}│${RESET}${GRAY}${MSG_TEXT}${RESET}${MSG_PAD}${COLOR}│${RESET}"
    echo -e "${COLOR}╰${HLINE}╯${RESET}"
}

print_slogan() {
    echo ""
    echo -e "  ${GRAY}BIM on the inside, drawings on the outside, data for everyone.${RESET}"
}

# Check arguments
if [[ "$1" == "-v" || "$1" == "--version" ]]; then
    print_box
    print_slogan
    echo ""
    exit 0
fi

if [[ "$1" == "-h" || "$1" == "--help" ]]; then
    echo ""
    echo -e "  ${BOLD}InfoBIM CLI${RESET} ${GRAY}v0.1.0${RESET}"
    echo -e "  ${GRAY}BIM on the inside, drawings on the outside, data for everyone.${RESET}"
    echo ""
    echo -e "${GRAY}${FULL_HLINE}${RESET}"
    echo ""
    echo -e "  ${WHITE}USAGE${RESET}"
    echo -e "    ${GRAY}./infobim [command]${RESET}"
    echo ""
    echo -e "  ${WHITE}COMMANDS${RESET}"
    echo ""
    echo -e "    ${CYAN}install [--docker]${RESET}"
    echo -e "      ${GRAY}Installs the stack and prepares the environment.${RESET}"
    echo -e "      ${GRAY}Default: Sets up Python virtual environment (venv).${RESET}"
    echo -e "      ${GRAY}--docker: Also sets up Docker environment.${RESET}"
    echo ""
    echo -e "    ${CYAN}check [--repair]${RESET}"
    echo -e "      ${GRAY}Verifies the system and project state.${RESET}"
    echo -e "      ${GRAY}Use --repair to attempt automatic fixes.${RESET}"
    # echo ""
    # echo -e "    ${CYAN}init${RESET}"
    # echo -e "      ${GRAY}Initializes a new engineering project (AECO sector).${RESET}"
    # echo -e "      ${GRAY}Sets up the standard folder structure and configuration.${RESET}"
    echo ""

    if [ -f "./data/config.yaml" ]; then
        echo -e "    ${CYAN}run${RESET}"
        echo -e "      ${GRAY}Runs the infoBIM application stack.${RESET}"
        echo ""
        echo -e "    ${CYAN}proj | project${RESET}"
        echo -e "      ${GRAY}Enters directly into project information.${RESET}"
        echo ""
    fi

    echo -e "    ${CYAN}ifc${RESET}"
    echo -e "      ${GRAY}Tools for visualizing and inspecting IFC files.${RESET}"
    echo ""
    # echo -e "${GRAY}${FULL_HLINE}${RESET}"
    # echo ""
    # echo -e "    ${CYAN}commit [message]${RESET}"
    # echo -e "      ${GRAY}Automates commits across multiple repositories.${RESET}"
    # echo -e "      ${GRAY}Usage: ./infobim commit \"Commit message\"${RESET}"
    # echo ""
    # echo -e "    ${CYAN}branch <action> <branch_name>${RESET}"
    # echo -e "      ${GRAY}Automates branch creation and checkout.${RESET}"
    # echo -e "      ${GRAY}Actions: create, checkout${RESET}"
    # echo ""
    echo -e "${GRAY}${FULL_HLINE}${RESET}"
    echo ""
    exit 0
fi

if [ "$1" == "commit" ]; then
    if [ -z "$2" ]; then
        echo ""
        print_message_box "$RED" "Error" "Missing commit message" "Usage: ./infobim commit \"Your commit message here\""
        echo ""
        exit 1
    fi
    if [[ ! -f "./stack/commit.sh" ]]; then
        echo ""
        print_message_box "$RED" "Error" "stack/commit.sh not found" "Please install the stack first."
        echo ""
        exit 1
    fi
    bash ./stack/commit.sh "$2"
    exit $?
fi

if [ "$1" == "checkout" ]; then
    if [[ -z "$2" ]]; then
        echo ""
        print_message_box "$RED" "Error" "Missing branch name" "Usage: ./infobim checkout <branch_name>"
        echo ""
        exit 1
    fi
    if [[ ! -f "./stack/branch.sh" ]]; then
        echo ""
        print_message_box "$RED" "Error" "stack/branch.sh not found" "Please install the stack first."
        echo ""
        exit 1
    fi
    bash ./stack/branch.sh "checkout" "$2"
    exit $?
fi

if [ "$1" == "branch" ]; then
    if [[ -z "$2" || -z "$3" ]]; then
        echo ""
        print_message_box "$RED" "Error" "Missing arguments" "Usage: ./infobim branch <create|checkout> <branch_name>"
        echo ""
        exit 1
    fi
    if [[ ! -f "./stack/branch.sh" ]]; then
        echo ""
        print_message_box "$RED" "Error" "stack/branch.sh not found" "Please install the stack first."
        echo ""
        exit 1
    fi
    bash ./stack/branch.sh "$2" "$3"
    exit $?
fi

if [ "$1" == "run" ]; then
    # If a second argument is provided, treat it as a capability run (Python)
    if [ -n "$2" ]; then
        if [[ ! -f "./stack/run.py" ]]; then
            echo ""
            print_message_box "$RED" "Error" "stack/run.py not found" "Please install the stack first."
            echo ""
            exit 1
        fi
        shift # remove 'run'
        if [[ ! -f "./venv/bin/python3" ]]; then
            echo ""
            print_message_box "$RED" "Error" "Environment Error" "Virtual environment not found.\nPlease run './infobim install' to set up the environment."
            echo ""
            exit 1
        fi
        ./venv/bin/python3 ./stack/run.py "$@"
        exit $?
    fi

    # Otherwise, run the default stack/run.sh
    if [[ ! -f "./stack/run.sh" ]]; then
        echo ""
        print_message_box "$RED" "Error" "stack/run.sh not found" "Please install the stack first."
        echo ""
        exit 1
    fi
    bash ./stack/run.sh
    exit $?
fi

if [ "$1" == "init" ]; then
    if [[ ! -f "./stack/init.sh" ]]; then
        echo ""
        print_message_box "$RED" "Error" "stack/init.sh not found" "Please install the stack first."
        echo ""
        exit 1
    fi
    bash ./stack/init.sh
    exit $?
fi

if [ "$1" == "proj" ] || [ "$1" == "project" ]; then
    if [[ ! -f "./stack/project.sh" ]]; then
        echo ""
        print_message_box "$RED" "Error" "stack/project.sh not found" "Please install the stack first."
        echo ""
        exit 1
    fi
    bash ./stack/project.sh
    exit $?
fi

if [ "$1" == "ifc" ]; then
    if [[ ! -f "./stack/ifc.sh" ]]; then
            echo ""
            print_message_box "$RED" "Error" "stack/ifc.sh not found" "Please install the stack first."
            echo ""
            exit 1
        fi
        shift
        bash ./stack/ifc.sh "$@"
        exit $?
fi


if [ "$1" == "check" ]; then
    if [[ ! -f "./stack/check.sh" ]]; then
        echo ""
        print_message_box "$RED" "Error" "stack/check.sh not found" "Please install the stack first."
        echo ""
        exit 1
    fi
    bash ./stack/check.sh "${@:2}"
    exit $?
fi

if [ "$1" == "install" ]; then
    # 1. Ensure Stack Submodule
    if [[ ! -d "./stack" || ! -f "./stack/init.sh" ]]; then
        echo -e "${CYAN}Checking git repository...${RESET}"
        if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
            echo -e "${YELLOW}Not a git repository. Initializing...${RESET}"
            git init
        else
            echo -e "${GREEN}Git repository detected.${RESET}"
        fi

        echo -e "${CYAN}Installing stack submodule...${RESET}"
        git submodule add -f git@github.com:InfoBIM-Community/infobim-ifc.git stack
        
        if [ $? -ne 0 ]; then
             print_message_box "$RED" "Error" "Installation failed" "Failed to install stack!"
             exit 1
        fi
    else
        echo -e "${GREEN}Stack submodule already installed.${RESET}"
    fi

    if [[ -f "./stack/infobim" ]]; then
        if [[ ! -L "./infobim" ]]; then
            echo -e "${CYAN}Linking infobim...${RESET}"
            ln -sf ./stack/infobim ./infobim
        fi
    fi

    if [[ -d "./stack/ontobdc" ]]; then
        if [[ -e "./ontobdc" && ! -L "./ontobdc" ]]; then
            echo -e "${CYAN}Removing existing ontobdc...${RESET}"
            rm -rf ./ontobdc
        fi

        if [[ ! -L "./ontobdc" ]]; then
            echo -e "${CYAN}Linking ontobdc...${RESET}"
            ln -sf ./stack/ontobdc ./ontobdc
        fi
    fi

    # 2. Setup Virtual Environment (Default)
    echo ""
    echo -e "${CYAN}Setting up Python Environment (venv)...${RESET}"
    bash ./stack/check.sh --repair --scope infra

    # 3. Setup Docker (Optional)
    if [[ "$2" == "--docker" ]]; then
        echo ""
        echo -e "${CYAN}Setting up Docker Environment...${RESET}"
        bash ./stack/check.sh --repair --scope ifc
    fi

    echo ""
    print_message_box "$GREEN" "Success!" "Installation finished" "Environment is ready."
    echo ""

    exit 0
fi

# --- Default Execution ---

print_box
print_slogan

echo -e "${GRAY}${FULL_HLINE}${RESET}"
echo ""

if [[ ! -d "./stack" || ! -f "./stack/init.sh" ]]; then
    print_message_box "$YELLOW" "Warning" "Stack not installed" "Use './infobim install' to install it first."
fi
echo ""
echo -e "  ${WHITE}Available commands:${RESET}"
# echo -e "    ${CYAN}commit${RESET}  ${GRAY}Automates commits across multiple repositories${RESET}"
# echo -e "    ${CYAN}checkout${RESET} ${GRAY}Switch branches across all repositories${RESET}"
# echo -e "    ${CYAN}branch${RESET}  ${GRAY}Automates branch creation and checkout${RESET}"
if [ -f "./data/config.yaml" ]; then
    echo -e "    ${CYAN}run${RESET}     ${GRAY}Runs the infoBIM application stack${RESET}"
    echo -e "    ${CYAN}proj${RESET}    ${GRAY}Enters directly into project information${RESET}"
fi
echo -e "    ${CYAN}ifc${RESET}     ${GRAY}Tools for visualizing and inspecting IFC files${RESET}"
echo ""
echo -e "  ${GRAY}Use${RESET} ${CYAN}./infobim [-h | --help]${RESET} ${GRAY}for more info.${RESET}"
echo ""

echo ""
